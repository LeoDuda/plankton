{
  format_version = 2
  num_rounds = 2
  task_data_filters = []
  task_result_filters = []
  #model_class_path = "segmentation_models.Unet"
  workflows = [
    {
      id = "scatter_and_gather"
      path = "nvflare.app_common.workflows.scatter_and_gather.ScatterAndGather"
        args {
            # argument of the ScatterAndGather class.
            # min number of clients required for ScatterAndGather controller to move to the next round
            # during the workflow cycle. The controller will wait until the min_clients returned from clients
            # before move to the next step.
            min_clients = 2

            # number of global round of the training.
            num_rounds = 2
        }
    }
  ]
  components = [
    {
      id = "persistor"
      path = "nvflare.app_opt.tf.model_persistor.TFModelPersistor"
      args {
        model {
          path = "planktonclas.model_utils.create_model"
          args={CONF = "planktonclas.config.get_conf_dict"
          }
        }
        save_name = "tf_model.ckpt"
      }
    }
    {
      id = "shareable_generator"
      path = "nvflare.app_common.shareablegenerators.full_model_shareable_generator.FullModelShareableGenerator"
      args {}
    }
    {
      id = "aggregator"
      path = "nvflare.app_common.aggregators.intime_accumulate_model_aggregator.InTimeAccumulateWeightedAggregator"
      args {
        expected_data_kind = "WEIGHT_DIFF"
      }
    }
  ]
}
